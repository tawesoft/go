package operator

// Code generated by (tawesoft.co.uk/go/operator) template-numbers.py: DO NOT EDIT.


// Some overflow checks with reference to stackoverflow.com/a/1514309/5654201

type int8Unary struct {
    Identity        func(int8) int8
    Abs             func(int8) int8
    Negation        func(int8) int8
    Zero            func(int8) bool
    NonZero         func(int8) bool
    Positive        func(int8) bool
    Negative        func(int8) bool
}

type int8UnaryChecked struct {
    Abs             func(int8) (int8, error)
    Negation        func(int8) (int8, error)
}

type int8Binary struct {
    Add             func(int8, int8) int8
    Sub             func(int8, int8) int8
    Mul             func(int8, int8) int8
    Div             func(int8, int8) int8
    Mod             func(int8, int8) int8
    
    Eq              func(int8, int8) bool
    Neq             func(int8, int8) bool
    Lt              func(int8, int8) bool
    Lte             func(int8, int8) bool
    Gt              func(int8, int8) bool
    Gte             func(int8, int8) bool
    
    And             func(int8, int8) int8
    Or              func(int8, int8) int8
    Xor             func(int8, int8) int8
    AndNot          func(int8, int8) int8
    
    Shl             func(int8, uint) int8
    Shr             func(int8, uint) int8
}

type int8BinaryChecked struct {
    Add             func(int8, int8) (int8, error)
    Sub             func(int8, int8) (int8, error)
    Mul             func(int8, int8) (int8, error)
    Div             func(int8, int8) (int8, error)
    
    Shl             func(int8, uint) (int8, error)
    Shr             func(int8, uint) (int8, error)
}

type int8Nary struct {
    Add             func(... int8) int8
    Sub             func(... int8) int8
    Mul             func(... int8) int8
}

type int8NaryChecked struct {
    Add             func(... int8) (int8, error)
    Sub             func(... int8) (int8, error)
    Mul             func(... int8) (int8, error)
}

// Int8 implements operations on one (unary), two (binary), or many (nary) arguments of type int8.
var Int8 = struct {
    Unary           int8Unary
    Binary          int8Binary
    Nary            int8Nary
    Reduce          func(operatorIdentity int8, operator func(int8, int8) int8, elements ... int8) int8
}{
    Unary:          int8Unary{
        Identity:   func(a int8) int8 { return a },
        Abs:        int8UnaryAbs,
        Negation:   func(a int8) int8 { return -a },
        Zero:       func(a int8) bool { return a == 0 },
        NonZero:    func(a int8) bool { return a != 0 },
        Positive:   int8UnaryPositive,
        Negative:   int8UnaryNegative,
    },
    
    Binary:          int8Binary{
        Add:        func(a int8, b int8) int8 { return a + b },
        Sub:        func(a int8, b int8) int8 { return a - b },
        Mul:        func(a int8, b int8) int8 { return a * b },
        Div:        func(a int8, b int8) int8 { return a / b },
        
        Eq:         func(a int8, b int8) bool { return a == b },
        Neq:        func(a int8, b int8) bool { return a != b },
        Lt:         func(a int8, b int8) bool { return a <  b },
        Lte:        func(a int8, b int8) bool { return a <= b },
        Gt:         func(a int8, b int8) bool { return a >  b },
        Gte:        func(a int8, b int8) bool { return a >= b },
        
        And:        func(a int8, b int8) int8 { return a & b },
        Or:         func(a int8, b int8) int8 { return a | b },
        Xor:        func(a int8, b int8) int8 { return a ^ b },
        AndNot:     func(a int8, b int8) int8 { return a &^ b },
        Mod:        func(a int8, b int8) int8 { return a % b },
        
        Shl:        func(a int8, b uint) int8 { return a << b },
        Shr:        func(a int8, b uint) int8 { return a >> b },
    },
    
    Nary:           int8Nary{
        Add:        int8NaryAdd,
        Mul:        int8NaryMul,
    },
    
    Reduce:         int8Reduce,
}

// Int8Checked implements operations on one (unary), two (binary), or many (nary) arguments of type int8, returning an
// error in cases such as overflow or an undefined operation.
var Int8Checked = struct {
    Unary           int8UnaryChecked
    Binary          int8BinaryChecked
    Nary            int8NaryChecked
    Reduce          func(operatorIdentity int8, operator func(int8, int8) (int8, error), elements ... int8) (int8, error)
}{
    Unary:          int8UnaryChecked{
        Abs:        int8UnaryCheckedAbs,
        Negation:   int8UnaryCheckedNegation,
    },
    
    Binary:         int8BinaryChecked{
        Add:        int8BinaryCheckedAdd,
        Sub:        int8BinaryCheckedSub,
        Mul:        int8BinaryCheckedMul,
        Div:        int8BinaryCheckedDiv,
        Shl:        int8BinaryCheckedShl,
    },
    
    Nary:           int8NaryChecked{
        Add:        int8NaryCheckedAdd,
        Mul:        int8NaryCheckedMul,
    },
    
    Reduce:         int8CheckedReduce,
}

func int8UnaryPositive(a int8) bool {
    return a > 0
}

func int8UnaryNegative(a int8) bool {
    return a < 0
}

func int8UnaryAbs(a int8) int8 {
    if a < 0 { return -a }
    return a
}

func int8UnaryCheckedAbs(a int8) (v int8, err error) {
    if a == minInt8 { return v, ErrorOverflow }
    if a < 0 { return -a, nil }
    return a, nil
}

func int8UnaryCheckedNegation(a int8) (v int8, err error) {
    if (a == minInt8) { return v, ErrorOverflow }
    return -a, nil
}

func int8BinaryCheckedAdd(a int8, b int8) (v int8, err error) {
    if (b > 0) && (a > (maxInt8 - b)) { return v, ErrorOverflow }
    if (b < 0) && (a < (minInt8 - b)) { return v, ErrorOverflow }
    return a + b, nil
}

func int8BinaryCheckedSub(a int8, b int8) (v int8, err error) {
    if (b < 0) && (a > (maxInt8 + b)) { return v, ErrorOverflow }
    if (b > 0) && (a < (minInt8 + b)) { return v, ErrorOverflow }
    return a - b, nil
}

func int8BinaryCheckedMul(a int8, b int8) (v int8, err error) {
    if (a == -1) && (b == minInt8) { return v, ErrorOverflow }
    if (b == -1) && (a == minInt8) { return v, ErrorOverflow }
    if (a > (maxInt8 / b)) { return v, ErrorOverflow }
    if (a < (minInt8 / b)) { return v, ErrorOverflow }
    
    return a * b, nil
}

func int8BinaryCheckedDiv(a int8, b int8) (v int8, err error) {
    if (b == -1) && (a == minInt8) { return v, ErrorOverflow }
    if (b == 0) { return v, ErrorUndefined }
    
    return a / b, nil
}

func int8BinaryCheckedShl(a int8, b uint) (v int8, err error) {
    if a < 0 { return v, ErrorUndefined }
    if b > uint(int8MostSignificantBit(maxInt8)) { return v, ErrorOverflow }
    return v, err
}

func int8MostSignificantBit(a int8) (result int) {
  for a > 0 {
      a >>= 1
      result++
  }
  return result;
}

func int8NaryAdd(xs ... int8) (result int8) {
    for i := 0; i < len(xs); i++ {
        result += xs[i]
    }
    return result
}

func int8NaryCheckedAdd(xs ... int8) (result int8, err error) {
    for i := 0; i < len(xs); i++ {
        result, err = int8BinaryCheckedAdd(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func int8NaryMul(xs ... int8) (result int8) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result *= xs[i]
    }
    return result
}

func int8NaryCheckedMul(xs ... int8) (result int8, err error) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result, err = int8BinaryCheckedMul(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func int8Reduce(operatorIdentity int8, operator func(int8, int8) int8, elements ... int8) (result int8) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result = operator(result, elements[i])
    }
    return result
}

func int8CheckedReduce(operatorIdentity int8, operator func(int8, int8) (int8, error), elements ... int8) (result int8, err error) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result, err = operator(result, elements[i])
        if err != nil { return result, err }
    }
    return result, err
}

