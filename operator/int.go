package operator

// Code generated by (tawesoft.co.uk/go/operator) template-numbers.py: DO NOT EDIT.


// Some overflow checks with reference to stackoverflow.com/a/1514309/5654201

type intUnary struct {
    Identity        func(int) int
    Abs             func(int) int
    Negation        func(int) int
    Zero            func(int) bool
    NonZero         func(int) bool
    Positive        func(int) bool
    Negative        func(int) bool
}

type intUnaryChecked struct {
    Abs             func(int) (int, error)
    Negation        func(int) (int, error)
}

type intBinary struct {
    Add             func(int, int) int
    Sub             func(int, int) int
    Mul             func(int, int) int
    Div             func(int, int) int
    Mod             func(int, int) int
    
    Eq              func(int, int) bool
    Neq             func(int, int) bool
    Lt              func(int, int) bool
    Lte             func(int, int) bool
    Gt              func(int, int) bool
    Gte             func(int, int) bool
    
    And             func(int, int) int
    Or              func(int, int) int
    Xor             func(int, int) int
    AndNot          func(int, int) int
    
    Shl             func(int, uint) int
    Shr             func(int, uint) int
}

type intBinaryChecked struct {
    Add             func(int, int) (int, error)
    Sub             func(int, int) (int, error)
    Mul             func(int, int) (int, error)
    Div             func(int, int) (int, error)
    
    Shl             func(int, uint) (int, error)
    Shr             func(int, uint) (int, error)
}

type intNary struct {
    Add             func(... int) int
    Sub             func(... int) int
    Mul             func(... int) int
}

type intNaryChecked struct {
    Add             func(... int) (int, error)
    Sub             func(... int) (int, error)
    Mul             func(... int) (int, error)
}

// Int implements operations on one (unary), two (binary), or many (nary) arguments of type int.
var Int = struct {
    Unary           intUnary
    Binary          intBinary
    Nary            intNary
    Reduce          func(operatorIdentity int, operator func(int, int) int, elements ... int) int
}{
    Unary:          intUnary{
        Identity:   func(a int) int { return a },
        Abs:        intUnaryAbs,
        Negation:   func(a int) int { return -a },
        Zero:       func(a int) bool { return a == 0 },
        NonZero:    func(a int) bool { return a != 0 },
        Positive:   intUnaryPositive,
        Negative:   intUnaryNegative,
    },
    
    Binary:          intBinary{
        Add:        func(a int, b int) int { return a + b },
        Sub:        func(a int, b int) int { return a - b },
        Mul:        func(a int, b int) int { return a * b },
        Div:        func(a int, b int) int { return a / b },
        
        Eq:         func(a int, b int) bool { return a == b },
        Neq:        func(a int, b int) bool { return a != b },
        Lt:         func(a int, b int) bool { return a <  b },
        Lte:        func(a int, b int) bool { return a <= b },
        Gt:         func(a int, b int) bool { return a >  b },
        Gte:        func(a int, b int) bool { return a >= b },
        
        And:        func(a int, b int) int { return a & b },
        Or:         func(a int, b int) int { return a | b },
        Xor:        func(a int, b int) int { return a ^ b },
        AndNot:     func(a int, b int) int { return a &^ b },
        Mod:        func(a int, b int) int { return a % b },
        
        Shl:        func(a int, b uint) int { return a << b },
        Shr:        func(a int, b uint) int { return a >> b },
    },
    
    Nary:           intNary{
        Add:        intNaryAdd,
        Mul:        intNaryMul,
    },
    
    Reduce:         intReduce,
}

// IntChecked implements operations on one (unary), two (binary), or many (nary) arguments of type int, returning an
// error in cases such as overflow or an undefined operation.
var IntChecked = struct {
    Unary           intUnaryChecked
    Binary          intBinaryChecked
    Nary            intNaryChecked
    Reduce          func(operatorIdentity int, operator func(int, int) (int, error), elements ... int) (int, error)
}{
    Unary:          intUnaryChecked{
        Abs:        intUnaryCheckedAbs,
        Negation:   intUnaryCheckedNegation,
    },
    
    Binary:         intBinaryChecked{
        Add:        intBinaryCheckedAdd,
        Sub:        intBinaryCheckedSub,
        Mul:        intBinaryCheckedMul,
        Div:        intBinaryCheckedDiv,
        Shl:        intBinaryCheckedShl,
    },
    
    Nary:           intNaryChecked{
        Add:        intNaryCheckedAdd,
        Mul:        intNaryCheckedMul,
    },
    
    Reduce:         intCheckedReduce,
}

func intUnaryPositive(a int) bool {
    return a > 0
}

func intUnaryNegative(a int) bool {
    return a < 0
}

func intUnaryAbs(a int) int {
    if a < 0 { return -a }
    return a
}

func intUnaryCheckedAbs(a int) (v int, err error) {
    if a == minInt { return v, ErrorOverflow }
    if a < 0 { return -a, nil }
    return a, nil
}

func intUnaryCheckedNegation(a int) (v int, err error) {
    if (a == minInt) { return v, ErrorOverflow }
    return -a, nil
}

func intBinaryCheckedAdd(a int, b int) (v int, err error) {
    if (b > 0) && (a > (maxInt - b)) { return v, ErrorOverflow }
    if (b < 0) && (a < (minInt - b)) { return v, ErrorOverflow }
    return a + b, nil
}

func intBinaryCheckedSub(a int, b int) (v int, err error) {
    if (b < 0) && (a > (maxInt + b)) { return v, ErrorOverflow }
    if (b > 0) && (a < (minInt + b)) { return v, ErrorOverflow }
    return a - b, nil
}

func intBinaryCheckedMul(a int, b int) (v int, err error) {
    if (a == -1) && (b == minInt) { return v, ErrorOverflow }
    if (b == -1) && (a == minInt) { return v, ErrorOverflow }
    if (a > (maxInt / b)) { return v, ErrorOverflow }
    if (a < (minInt / b)) { return v, ErrorOverflow }
    
    return a * b, nil
}

func intBinaryCheckedDiv(a int, b int) (v int, err error) {
    if (b == -1) && (a == minInt) { return v, ErrorOverflow }
    if (b == 0) { return v, ErrorUndefined }
    
    return a / b, nil
}

func intBinaryCheckedShl(a int, b uint) (v int, err error) {
    if a < 0 { return v, ErrorUndefined }
    if b > uint(intMostSignificantBit(maxInt)) { return v, ErrorOverflow }
    return v, err
}

func intMostSignificantBit(a int) (result int) {
  for a > 0 {
      a >>= 1
      result++
  }
  return result;
}

func intNaryAdd(xs ... int) (result int) {
    for i := 0; i < len(xs); i++ {
        result += xs[i]
    }
    return result
}

func intNaryCheckedAdd(xs ... int) (result int, err error) {
    for i := 0; i < len(xs); i++ {
        result, err = intBinaryCheckedAdd(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func intNaryMul(xs ... int) (result int) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result *= xs[i]
    }
    return result
}

func intNaryCheckedMul(xs ... int) (result int, err error) {
    result = 1
    for i := 0; i < len(xs); i++ {
        result, err = intBinaryCheckedMul(result, xs[i])
        if err != nil { return result, err }
    }
    return result, nil
}

func intReduce(operatorIdentity int, operator func(int, int) int, elements ... int) (result int) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result = operator(result, elements[i])
    }
    return result
}

func intCheckedReduce(operatorIdentity int, operator func(int, int) (int, error), elements ... int) (result int, err error) {
    result = operatorIdentity
    for i := 0; i < len(elements); i++ {
        result, err = operator(result, elements[i])
        if err != nil { return result, err }
    }
    return result, err
}

